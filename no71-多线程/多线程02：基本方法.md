地址：
>https://github.com/yoyogrape/javademo/blob/master/src/main/java/com/songjn/multi_thread/MultiThread.java
## 创建线程的两种基本方法
 * 继承Thread类
 * 实现Runable接口
 
```
1)继承Thread实现多线程
class ThreadOne extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            // 取得当前线程的名字
            System.out.println(Thread.currentThread().getName() + "运行，i = " + i);
        }
    }
}
public static void main(String[] args) {
    ThreadOne threadOne = new ThreadOne();
    threadOne.setName("我是自定义的线程1");
    threadOne.start();
    System.out.println(Thread.currentThread().getName());
}
```

```
2)实现Runnable接口实现多线程
class ThreadTwo implements Runnable {  
    @Override
    public void run() {    // 覆写run()方法
        for (int i = 0; i < 3; i++) {
            // 取得当前线程的名字
            System.out.println(Thread.currentThread().getName() + "运行，i = " + i);
        }
    }
}
public static void main(String[] args){ 
    Thread t1 = new Thread(new ThreadTwo());
    t1.setName("第二个线程2");
    t1.start(); 
}
```
#### 因为java是单继承多实现，所以一般情况下都用实现Runnable接口的方式来写多线程

## Thread.sleep()方法是一个静态方法
 * sleep()方法属于Thread类，主要的作用是让当前线程停止执行，
把cpu让给其他线程执行，但不会释放对象锁和监控的状态，
到了指定时间后线程又会自动恢复运行状态
```

```

## wait() notify()
 * wait()属于Object类，与sleep()的区别是当前线程会释放锁，
进入等待此对象的等待锁定池。比方说，线程A调用Obj.wait(),
线程A就会停止运行，而转为等待状态。至于等待多长时间?
那就看其他线程是否调用Obj.notify().其优势显而易见，成为多个线程之间进行通讯的有手段！  
 * **注意：它必须包含在Synchronzied语句中，无论是wait()还是notify()都需要首先获得目标的对象的一个监视器**
```

```

## Synchronzied
 * 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的部分,进入同步代码前要获得给定对象的锁
 * 修饰一个实例方法，进入同步代码前要获得当前实例的锁
 * 修饰一个静态方法，进入同步代码前要获得当前类的锁
```

```

## join()
 * 在某些情况下，子线程需要进行大量的耗时运算，主线程可能会在子线程执行结束之前结束，
但是如果主线程又需要用到子线程的结果，换句话说，就是主线程需要在子线程执行之后再结束。这就需要用到join()方法
```

```

## yield()
 * 一个线程调用yield()意味着告诉虚拟机自己非常乐于助人，可以把自己的位置让给其他线程(这只是暗示，并不表绝对)。
 * 但得注意，让出cpu并不代表当前线程不执行了。当前线程让出cpu后，还会进行cpu资源的争夺，但是能不能再次分配到，就不一定了
```

```

## isAlive()
 * 线程处于“新建”状态时，线程调用isAlive()方法返回false。
 * 在线程的run()方法结束之前，即没有进入死亡状态之前，线程调用isAlive()方法返回true.
```

```

## interrupt()
 * 中断线程，将会设置该线程的中断状态位，即设置为true，
 * 中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身
```

```

## setDaemon()
 * 守护线程，在Java中，只要一个线程没有执行完（一个线程在运行），则整个Java的进程不会消失，
 * 所以此时可以设置一个后台线程，这样即使java线程结束了，则后台线程依旧会继续执行。
```

```

## getPriority()
 * 线程的优先级，优先级分为最低，最高，普通三个（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY）
```

```

## setPriority()
 * 更改线程优先级。
 ```
 MIN_PRRORITY = 1
 NORM_PRIORITY = 5
 MAX_PRIORITY = 10
 ```

## activeCount()
 * 程序中活跃的线程数。
```

```


